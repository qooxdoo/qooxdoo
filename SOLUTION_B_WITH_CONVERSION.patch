# Lösung B: MIT camelCase Konvertierung + Collision Detection
# Nutze diese Lösung wenn Tests FEHLSCHLAGEN (Konvertierung ist nötig)

## Änderungen

### File: source/class/qx/ui/form/Form.js

```javascript
// In add() Methode (Zeilen 76-114):
add(item, label, validator, name, validatorContext, options) {
  // ... existing code ...

  // if no name is given, use the label without not working character
  if (name == null) {
    name = label.replace(/\s+|&|-|\+|\*|\/|\||!|\.|,|:|\?|;|~|%|\{|\}|\(|\)|\[|\]|<|>|=|\^|@|\\/g, "");
  }

  // KEINE Konvertierung hier - Form speichert Original-Namen
  this.__groups[this._groupCounter].names.push(name);

  // ... rest of method ...
}
```

### File: source/class/qx/data/controller/Form.js

```javascript
members: {
  __objectController: null,
  __bindingOptions: null,

  /**
   * Helper method to convert form field name to camelCase for model properties.
   * Ensures v8 compatibility where property names must follow camelCase convention.
   *
   * @param name {String} The form field name
   * @return {String} The camelCase converted name
   */
  __convertNameToCamelCase(name) {
    if (!name) {
      return name;
    }

    // For deep binding, convert each part
    var parts = name.split(".");
    var convertedParts = parts.map(function (part) {
      return qx.lang.String.firstLow(part);
    });

    return convertedParts.join(".");
  },

  /**
   * Creates model with camelCase property names and collision detection.
   */
  createModel(includeBubbleEvents) {
    var target = this.getTarget();
    if (target == null) {
      throw new Error("No target is set.");
    }

    var items = target.getItems();
    var data = {};
    var nameMapping = {}; // Track collisions

    for (var name in items) {
      // Convert to camelCase for v8 compatibility
      var camelCaseName = this.__convertNameToCamelCase(name);

      // COLLISION DETECTION
      if (nameMapping[camelCaseName] && nameMapping[camelCaseName] !== name) {
        throw new Error(
          "Form field naming collision detected (issue #10808): " +
          "Fields '" + nameMapping[camelCaseName] + "' and '" + name + "' " +
          "both convert to the same camelCase property name '" + camelCaseName + "'.\n\n" +
          "This happens when field names differ only in capitalization (e.g., 'Username' and 'username').\n\n" +
          "To fix this issue:\n" +
          "  1. Rename one of the fields to have a distinct name\n" +
          "  2. Ensure field names are unique when converted to camelCase\n\n" +
          "Conflicting fields:\n" +
          "  - '" + nameMapping[camelCaseName] + "'\n" +
          "  - '" + name + "'\n" +
          "Both map to: '" + camelCaseName + "'"
        );
      }

      nameMapping[camelCaseName] = name;

      // Process the field value
      var names = camelCaseName.split(".");
      var currentData = data;
      for (var i = 0; i < names.length; i++) {
        if (i + 1 == names.length) {
          var clazz = items[name].constructor;
          var itemValue = null;
          if (qx.Class.hasInterface(clazz, qx.ui.core.ISingleSelection)) {
            itemValue = items[name].getModelSelection().getItem(0) || null;
          } else {
            itemValue = items[name].getValue();
          }
          if (this.__bindingOptions[name] && this.__bindingOptions[name][1]) {
            itemValue = this.__bindingOptions[name][1].converter(itemValue);
          }
          currentData[names[i]] = itemValue;
        } else {
          if (!currentData[names[i]]) {
            currentData[names[i]] = {};
          }
          currentData = currentData[names[i]];
        }
      }
    }

    var model = qx.data.marshal.Json.createModel(data, includeBubbleEvents);
    this.setModel(model);
    return model;
  },

  // Alle anderen Methoden nutzen auch __convertNameToCamelCase():
  __setUpBinding() {
    // ... code ...
    for (var name in items) {
      var modelPropertyName = this.__convertNameToCamelCase(name);
      // ... use modelPropertyName for binding ...
    }
  },

  updateModel() {
    // ... code ...
    for (var name in items) {
      var modelPropertyName = this.__convertNameToCamelCase(name);
      // ... use modelPropertyName ...
    }
  },

  _applyModel(value, old) {
    // ... code ...
    for (var name in items) {
      var modelPropertyName = this.__convertNameToCamelCase(name);
      // ... use modelPropertyName for removeTarget ...
    }
  },

  __tearDownBinding(oldTarget) {
    // ... code ...
    for (var name in items) {
      var modelPropertyName = this.__convertNameToCamelCase(name);
      // ... use modelPropertyName for removeTarget ...
    }
  },

  addBindingOptions(name, model2target, target2model) {
    // ... code ...
    var modelPropertyName = this.__convertNameToCamelCase(name);
    // ... use modelPropertyName ...
  }
}
```

## Vorteile
- ✅ Folgt qooxdoo Convention (camelCase)
- ✅ Verhindert Kollisionen (fail-fast mit klarer Fehlermeldung)
- ✅ Funktioniert garantiert mit v8
- ✅ form.getItem("Username") funktioniert (Form speichert Original)
- ✅ model.username (camelCase im Model)
- ✅ Klare Trennung: Form = Original, Model = Convention

## Nachteile
- ⚠️ Etwas komplexer
- ⚠️ Zwei Namen für gleiche Sache (Form: "Username", Model: "username")

## Collision Detection
- Wirft Error wenn "Username" UND "username" beide als Felder existieren
- Fehlermeldung erklärt Problem und gibt Lösungsvorschläge
- Fail-fast: Fehler beim createModel(), nicht erst beim Binding

## Test-Erwartungen
- model.getUsername() sollte existieren (camelCase konvertiert)
- model.getEmailAddress() sollte existieren
- form.getItem("Username") sollte field finden (Original-Name)
- Collision test sollte Error werfen

## Wann nutzen?
- Wenn Tests FEHLSCHLAGEN
- Wenn qooxdoo v8 lowercase properties erfordert
- Wenn v8 strikte Validations hat
- **Dies ist die SICHERE Wahl** - funktioniert in jedem Fall
