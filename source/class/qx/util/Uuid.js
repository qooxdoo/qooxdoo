/* ************************************************************************

   qooxdoo - the new era of web development

   http://qooxdoo.org

   Copyright:
     2019 Zenesis Ltd http://www.zenesis.com

   License:
     MIT: https://opensource.org/licenses/MIT
     See the LICENSE file in the project's top-level directory for details.

   Authors:
     * John Spackman (https://github.com/johnspackman/)

************************************************************************ */

/**
 * Helper class for generating UUIDs
 */
qx.Class.define("qx.util.Uuid", {
  extend: qx.core.Object,

  statics: {
    /**
     * Creates an RFC4122 compliant UUID/v4 - that means that collisions are possible but highly
     * unlikely (it has been said that "you would need to do-loop uuid() at max speed for 73,067
     * years for a 50% chance of one collision").
     *
     * The implementation of this is from https://github.com/jchook/uuid-random
     *
     * @returns {String} eg 534f57dc-301c-417a-ae4c-11a921716307
     */
    createUuidV4: null
  }
});

/**
 * @ignore(crypto)
 * @ignore(module)
 * @ignore(module.exports)
 * @ignore(Uint8Array)
 * @ignore(require)
 */

(function () {
  var buf,
    bufIdx = 0,
    hexBytes = [],
    i;

  // Pre-calculate toString(16) for speed
  for (i = 0; i < 256; i++) {
    hexBytes[i] = (i + 0x100).toString(16).substr(1);
  }

  // Buffer random numbers for speed
  // Reduce memory usage by decreasing this number (min 16)
  // or improve speed by increasing this number (try 16384)
  uuid.BUFFER_SIZE = 4096;

  // Binary uuids
  uuid.bin = uuidBin;

  // Clear buffer
  uuid.clearBuffer = function () {
    buf = null;
    bufIdx = 0;
  };

  // Test for uuid
  uuid.test = function (uuid) {
    if (typeof uuid === "string") {
      return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/.test(
        uuid
      );
    }
    return false;
  };

  // Node & Browser support
  var crypt0;
  if (typeof crypto !== "undefined") {
    crypt0 = crypto;
  } else if (
    typeof window !== "undefined" &&
    typeof window.msCrypto !== "undefined"
  ) {
    crypt0 = window.msCrypto; // IE11
  }

  if (typeof module !== "undefined" && typeof require === "function") {
    crypt0 = crypt0 || require("crypto");
  }
  qx.util.Uuid.createUuidV4 = uuid;

  // Use best available PRNG
  // Also expose this so you can override it.
  uuid.randomBytes = (function () {
    if (crypt0) {
      if (crypt0.randomBytes) {
        return crypt0.randomBytes;
      }
      if (crypt0.getRandomValues) {
        return function (n) {
          var bytes = new Uint8Array(n);
          crypt0.getRandomValues(bytes);
          return bytes;
        };
      }
    }
    return function (n) {
      var i,
        r = [];
      for (i = 0; i < n; i++) {
        r.push(Math.floor(Math.random() * 256));
      }
      return r;
    };
  })();

  // Buffer some random bytes for speed
  function randomBytesBuffered(n) {
    if (!buf || bufIdx + n > uuid.BUFFER_SIZE) {
      bufIdx = 0;
      buf = uuid.randomBytes(uuid.BUFFER_SIZE);
    }
    return buf.slice(bufIdx, (bufIdx += n));
  }

  // uuid.bin
  function uuidBin() {
    var b = randomBytesBuffered(16);
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    return b;
  }

  // String UUIDv4 (Random)
  function uuid() {
    var b = uuidBin();
    return (
      hexBytes[b[0]] +
      hexBytes[b[1]] +
      hexBytes[b[2]] +
      hexBytes[b[3]] +
      "-" +
      hexBytes[b[4]] +
      hexBytes[b[5]] +
      "-" +
      hexBytes[b[6]] +
      hexBytes[b[7]] +
      "-" +
      hexBytes[b[8]] +
      hexBytes[b[9]] +
      "-" +
      hexBytes[b[10]] +
      hexBytes[b[11]] +
      hexBytes[b[12]] +
      hexBytes[b[13]] +
      hexBytes[b[14]] +
      hexBytes[b[15]]
    );
  }
})();
